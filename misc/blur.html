<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Gaussian Blur</title>
    <meta name="description" content="Lets you blur an image A LOT" />
    <meta name="theme-color" content="#4fa1a7" />

    <link rel="stylesheet" type="text/css" href="/sheep3.css" />
    <link rel="stylesheet" type="text/css" href="/reform/v1/index.css" />
    <script src="/sheep3.js" charset="utf-8"></script>
  </head>
  <body>
    <form class="main" role="main" action="javascript:">
      <h1>Big Beautiful Blur</h1>
      <p>
        Blurs your image with Gaussian blur. You can blur it a lot if you want.
      </p>

      <div class="two-col-io reform:io">
        <label class="input-controls file">
          <input
            type="file"
            name="image"
            accept="image/*"
            class="hidden-accessible reform:image-input reform:paste-target"
            data-default="PXL_20230624_020141093.jpg"
          />
          <span class="icon icon-upload"></span>
          <span class="file-label">Choose or drop a photo</span>
          <span class="file-name">No file selected</span>
        </label>
        <div class="image-content input-content"><canvas></canvas></div>
        <div class="image-content output-content">
          <canvas
            id="texture"
            data-deps="image"
            class="reform:canvas-element reform:io-ignore"
            style="display: none"
          ></canvas>
          <div
            class="reform:io-ignore"
            style="display: none"
            id="output"
            data-deps="texture blur resolution giveUp"
          ></div>
          <canvas id="canvas2d" data-deps="output" style="display: no"></canvas>
        </div>
        <div class="output-controls">
          <a class="file download">
            <span class="icon icon-download"></span>
            <span class="file-label">Download</span>
            <span class="file-name">No file available</span>
          </a>
          <button
            type="button"
            class="icon icon-copy"
            aria-label="Copy"
          ></button>
          <button
            type="button"
            class="icon icon-share"
            aria-label="Share"
          ></button>
        </div>
      </div>

      <div class="field-label range-wrapper">
        <label class="range-label">
          <span class="label-primary">Blur radius</span>
          <span class="label-secondary">
            Mathematically, the standard deviation &sigma; of the Gaussian blur,
            in pixels. It's not really a radius&mdash;the Gaussian distribution
            goes on forever, but I cut it off at some point because it somewhat
            quickly gets really close to zero.
          </span>
          <input type="range" name="blur" min="0" max="500" value="80" />
        </label>
        <input
          type="text"
          inputmode="numeric"
          pattern="[0-9]*"
          name="blur"
          min="0"
          value="80"
          aria-label="Blur value"
        />
      </div>

      <div class="field-label range-wrapper">
        <label class="range-label">
          <span class="label-primary">Gaussian cutoff</span>
          <span class="label-secondary">
            Determines to cut off the Gaussian. A cutoff of <em>x</em> means
            that the blur will stop taking into account pixels that will be
            multipled by less than <em>x</em>/255. A higher cutoff means a less
            accurate blur, but it'll be able to stop calculating the blur
            earlier.
          </span>
          <input type="range" name="giveUp" min="1" max="255" value="1" />
        </label>
        <input
          type="text"
          inputmode="numeric"
          pattern="[0-9]*"
          name="giveUp"
          min="1"
          max="255"
          value="1"
          aria-label="Gaussian cutoff value"
        />
      </div>

      <div class="field-label range-wrapper">
        <label class="range-label">
          <span class="label-primary">Resolution</span>
          <span class="label-secondary">
            The number of pixels to skip by, in pixels. This decreases the
            quality, but it allows the blur to account for fewer pixels. This
            might make sense for a large blur radius in a large image, where
            pixels next to each other might be the same color. However, if it
            gets too large, you might see a grid pattern appear as it starts
            skipping over noticeable details.
          </span>
          <input type="range" name="resolution" min="1" max="50" value="1" />
        </label>
        <input
          type="text"
          inputmode="numeric"
          pattern="[0-9]*"
          name="resolution"
          min="1"
          value="1"
          aria-label="Resolution value"
        />
      </div>
    </form>

    <script type="module">
      import { on, Out } from '/reform/v1/index.js'

      let webGpu
      async function setupWebgpu (canvas) {
        const context = canvas.getContext('webgpu')
        const format = navigator.gpu.getPreferredCanvasFormat()
        const adapter = await navigator.gpu.requestAdapter()
        const device = await adapter.requestDevice()
        device.lost.then(({ reason, message }) => {
          throw new Error(`WebGPU device lost: ${message} (reason: ${reason})`)
        })
        context.configure({ device, format })

        device.pushErrorScope('internal')
        device.pushErrorScope('out-of-memory')
        device.pushErrorScope('validation')

        const module = device.createShaderModule({
          code: await fetch('./blur.wgsl').then(r => r.text())
        })
        const { messages } = await module.getCompilationInfo()
        if (messages.some(message => message.type === 'error')) {
          console.log(messages)
          throw new SyntaxError(
            'Shader failed to compile:' +
              messages
                .map(
                  message =>
                    `\nblur.wgsl:${message.lineNum}:${message.linePos}: ${message.message}`
                )
                .join('')
          )
        }

        const pipeline = device.createRenderPipeline({
          layout: 'auto',
          vertex: { module, entryPoint: 'vertex_main' },
          fragment: {
            module,
            entryPoint: 'fragment_main',
            targets: [{ format }]
          }
        })

        const directionYUniform = device.createBuffer({
          size: 4,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        })
        device.queue.writeBuffer(directionYUniform, 0, new Int32Array([0]))
        const directionXUniform = device.createBuffer({
          size: 4,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        })
        device.queue.writeBuffer(directionYUniform, 0, new Int32Array([1]))

        const dimensionsUniform = device.createBuffer({
          size: 4 * 2,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        })
        const blurUniform = device.createBuffer({
          size: 4,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        })
        const resolutionUniform = device.createBuffer({
          size: 4,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        })
        const giveUpUniform = device.createBuffer({
          size: 4,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        })

        const groupY = device.createBindGroup({
          layout: pipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: device.createSampler() },
            { binding: 1, resource: { buffer: directionYUniform } },
            { binding: 2, resource: { buffer: dimensionsUniform } },
            { binding: 3, resource: { buffer: blurUniform } },
            { binding: 4, resource: { buffer: resolutionUniform } },
            { binding: 5, resource: { buffer: giveUpUniform } }
          ]
        })
        const groupX = device.createBindGroup({
          layout: pipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: device.createSampler() },
            { binding: 1, resource: { buffer: directionXUniform } },
            { binding: 2, resource: { buffer: dimensionsUniform } },
            { binding: 3, resource: { buffer: blurUniform } },
            { binding: 4, resource: { buffer: resolutionUniform } },
            { binding: 5, resource: { buffer: giveUpUniform } }
          ]
        })

        const validationError = await device.popErrorScope()
        const memoryError = await device.popErrorScope()
        const internalError = await device.popErrorScope()
        if (validationError) {
          throw new TypeError(
            `WebGPU validation error: ${validationError.message}`
          )
        }
        if (memoryError) {
          throw new TypeError(
            `WebGPU out of memory error: ${memoryError.message}`
          )
        }
        if (internalError) {
          throw new TypeError(`WebGPU internal error: ${internalError.message}`)
        }

        return {
          device,
          blurUniform,
          resolutionUniform,
          giveUpUniform,
          dimensionsUniform,
          groupY,
          groupX,
          pipeline,
          context,
          format
        }
      }

      let textureY
      let textureX
      let textureExecId = 0
      on('texture', async (canvas, { image }) => {
        const execId = ++textureExecId

        webGpu ??= setupWebgpu(canvas)
        const { device, dimensionsUniform, pipeline, format } = await webGpu
        if (execId !== textureExecId) {
          return
        }

        const source = await createImageBitmap(image.canvas, {
          colorSpaceConversion: 'none'
        })
        if (execId !== textureExecId) {
          return
        }
        textureY?.destroy()
        textureY = device.createTexture({
          label: 'texture',
          format,
          size: [source.width, source.height],
          usage:
            GPUTextureUsage.TEXTURE_BINDING |
            GPUTextureUsage.COPY_DST |
            GPUTextureUsage.RENDER_ATTACHMENT
        })
        device.queue.copyExternalImageToTexture(
          { source, flipY: false },
          { texture: textureY },
          { width: source.width, height: source.height }
        )

        textureX?.destroy()
        textureX = device.createTexture({
          label: 'texture',
          format,
          size: [source.width, source.height],
          usage:
            GPUTextureUsage.TEXTURE_BINDING |
            GPUTextureUsage.COPY_DST |
            GPUTextureUsage.RENDER_ATTACHMENT
        })

        device.queue.writeBuffer(
          dimensionsUniform,
          0,
          new Float32Array([source.width, source.height])
        )
        canvas.width = source.width
        canvas.height = source.height

        return {
          groupY: device.createBindGroup({
            layout: pipeline.getBindGroupLayout(1),
            entries: [{ binding: 0, resource: textureY.createView() }]
          }),
          textureX,
          groupX: device.createBindGroup({
            layout: pipeline.getBindGroupLayout(1),
            entries: [{ binding: 0, resource: textureX.createView() }]
          }),
          fileName: image.canvas.dataset.name
        }
      })

      let outputExecId = 0
      on(
        'output',
        async (
          _,
          {
            texture: {
              groupY: textureGroupY,
              groupX: textureGroupX,
              textureX,
              fileName
            },
            blur,
            resolution,
            giveUp
          }
        ) => {
          const execId = ++outputExecId

          const {
            device,
            blurUniform,
            resolutionUniform,
            giveUpUniform,
            context,
            pipeline,
            groupY,
            groupX
          } = await webGpu
          if (execId !== outputExecId) {
            return
          }

          device.queue.writeBuffer(blurUniform, 0, new Float32Array([blur]))
          device.queue.writeBuffer(
            resolutionUniform,
            0,
            new Int32Array([resolution])
          )
          device.queue.writeBuffer(giveUpUniform, 0, new Float32Array([giveUp]))

          const encoder = device.createCommandEncoder()
          const passY = encoder.beginRenderPass({
            colorAttachments: [
              {
                view: textureX.createView(),
                clearValue: [1, 0, 1, 1],
                loadOp: 'clear',
                storeOp: 'store'
              }
            ]
          })
          passY.setPipeline(pipeline)
          passY.setBindGroup(0, groupY)
          passY.setBindGroup(1, textureGroupY)
          passY.draw(6)
          passY.end()
          const passX = encoder.beginRenderPass({
            colorAttachments: [
              {
                view: context.getCurrentTexture().createView(),
                clearValue: [1, 0, 1, 1],
                loadOp: 'clear',
                storeOp: 'store'
              }
            ]
          })
          passX.setPipeline(pipeline)
          passX.setBindGroup(0, groupX)
          passX.setBindGroup(1, textureGroupX)
          passX.draw(6)
          passX.end()
          device.queue.submit([encoder.finish()])

          // toBlob/toDataURL returns a transparent image for WebGPU on Chrome
          // https://issues.chromium.org/issues/40168039
          return { fileName, canvas: context.canvas }
        }
      )

      on('canvas2d', (ctx, { output: { fileName, canvas } }) => {
        ctx.canvas.width = canvas.width
        ctx.canvas.height = canvas.height
        // For some reason this works
        ctx.drawImage(canvas, 0, 0)

        return Out.from(fileName + '.png', ctx)
      })
    </script>
  </body>
</html>
