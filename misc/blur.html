<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Gaussian Blur</title>
    <meta name="description" content="Lets you blur an image A LOT" />
    <meta name="theme-color" content="#4fa1a7" />

    <link rel="stylesheet" type="text/css" href="/sheep3.css" />
    <link rel="stylesheet" type="text/css" href="/reform/v1/index.css" />
    <script src="/sheep3.js" charset="utf-8"></script>
  </head>
  <body>
    <form class="main" role="main" action="javascript:">
      <h1>Big Beautiful Blur</h1>
      <p>
        Blurs your image with Gaussian blur. You can blur it a lot if you want.
      </p>

      <div class="two-col-io reform:io">
        <label class="input-controls file">
          <input
            type="file"
            name="image"
            accept="image/*"
            class="hidden-accessible reform:image-input reform:paste-target"
            data-default="blur_taipei_crosswalk.jpg"
          />
          <span class="icon icon-upload"></span>
          <span class="file-label">Choose or drop a photo</span>
          <span class="file-name">No file selected</span>
        </label>
        <div class="image-content input-content"><canvas></canvas></div>
        <div class="image-content output-content">
          <canvas
            id="webgpu"
            class="reform:canvas-element reform:io-ignore"
            style="display: none"
          ></canvas>
          <div
            id="texture"
            data-deps="webgpu image"
            class="reform:io-ignore"
            style="display: none"
          ></div>
          <div
            id="output"
            data-deps="webgpu texture weights resolution"
            class="reform:io-ignore"
            style="display: none"
          ></div>
          <canvas id="canvas2d" data-deps="output" style="display: no"></canvas>
        </div>
        <div class="output-controls">
          <a class="file download">
            <span class="icon icon-download"></span>
            <span class="file-label">Download</span>
            <span class="file-name">No file available</span>
          </a>
          <button
            type="button"
            class="icon icon-copy"
            aria-label="Copy"
          ></button>
          <button
            type="button"
            class="icon icon-share"
            aria-label="Share"
          ></button>
        </div>
      </div>

      <p>
        With your settings, blurring will be
        <span id="weights" data-deps="webgpu blur cutoff resolution"></span>x
        slower compared to directly copying the image.
      </p>

      <div class="field-label range-wrapper">
        <label class="range-label">
          <span class="label-primary">Blur</span>
          <span class="label-secondary">
            The standard deviation &sigma; of the Gaussian blur, in pixels..
          </span>
          <input
            type="range"
            name="blur"
            min="0"
            max="500"
            step="0.1"
            value="80"
          />
        </label>
        <input
          type="number"
          name="blur"
          min="0"
          step="0.1"
          value="80"
          aria-label="Blur value"
        />
      </div>

      <div class="field-label range-wrapper">
        <label class="range-label">
          <span class="label-primary">Gaussian cutoff</span>
          <span class="label-secondary">
            When to cut off the Gaussian, in multiples of the standard deviation
            &sigma; ("blur radius"). The Gaussian continues infinitely, but it
            also drops close to zero fairly quickly, so we can cut it off at
            some point.
            <span id="cutoff-calc" data-deps="cutoff"></span>
          </span>
          <input
            type="range"
            name="cutoff"
            min="0"
            max="5"
            step="0.01"
            value="3"
          />
        </label>
        <input
          type="number"
          name="cutoff"
          min="0"
          step="0.01"
          value="3"
          aria-label="Gaussian cutoff value"
        />
      </div>

      <div class="field-label range-wrapper">
        <label class="range-label">
          <span class="label-primary">Resolution</span>
          <span class="label-secondary">
            The number of pixels to skip by for a faster blur. This works best
            if nearby pixels are similar in color; otherwise, a grid pattern can
            appear.
          </span>
          <input type="range" name="resolution" min="1" max="50" value="1" />
        </label>
        <input
          type="text"
          inputmode="numeric"
          pattern="[0-9]*"
          name="resolution"
          min="1"
          value="1"
          aria-label="Resolution value"
        />
      </div>
    </form>

    <script type="module">
      import { on, Out } from '/reform/v1/index.js'
      import { erf } from './erf.js'

      on('webgpu', async canvas => {
        const context = canvas.getContext('webgpu')
        const format = navigator.gpu.getPreferredCanvasFormat()
        const adapter = await navigator.gpu.requestAdapter()
        const device = await adapter.requestDevice()
        device.lost.then(({ reason, message }) => {
          throw new Error(`WebGPU device lost: ${message} (reason: ${reason})`)
        })
        context.configure({ device, format })

        device.pushErrorScope('internal')
        device.pushErrorScope('out-of-memory')
        device.pushErrorScope('validation')

        const module = device.createShaderModule({
          code: await fetch('./blur.wgsl').then(r => r.text())
        })
        const { messages } = await module.getCompilationInfo()
        if (messages.some(message => message.type === 'error')) {
          console.log(messages)
          throw new SyntaxError(
            'Shader failed to compile:' +
              messages
                .map(
                  message =>
                    `\nblur.wgsl:${message.lineNum}:${message.linePos}: ${message.message}`
                )
                .join('')
          )
        }

        const pipeline = device.createRenderPipeline({
          layout: 'auto',
          vertex: { module, entryPoint: 'vertex_main' },
          fragment: {
            module,
            entryPoint: 'fragment_main',
            targets: [{ format }]
          }
        })

        const directionYUniform = device.createBuffer({
          size: 4,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        })
        device.queue.writeBuffer(directionYUniform, 0, new Int32Array([0]))
        const directionXUniform = device.createBuffer({
          size: 4,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        })
        device.queue.writeBuffer(directionYUniform, 0, new Int32Array([1]))

        const dimensionsUniform = device.createBuffer({
          size: 4 * 2,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        })
        const resolutionUniform = device.createBuffer({
          size: 4,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
        })

        const groupY = device.createBindGroup({
          layout: pipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: device.createSampler() },
            { binding: 1, resource: { buffer: directionYUniform } },
            { binding: 2, resource: { buffer: dimensionsUniform } },
            { binding: 3, resource: { buffer: resolutionUniform } }
          ]
        })
        const groupX = device.createBindGroup({
          layout: pipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: device.createSampler() },
            { binding: 1, resource: { buffer: directionXUniform } },
            { binding: 2, resource: { buffer: dimensionsUniform } },
            { binding: 3, resource: { buffer: resolutionUniform } }
          ]
        })

        const validationError = await device.popErrorScope()
        const memoryError = await device.popErrorScope()
        const internalError = await device.popErrorScope()
        if (validationError) {
          throw new TypeError(
            `WebGPU validation error: ${validationError.message}`
          )
        }
        if (memoryError) {
          throw new TypeError(
            `WebGPU out of memory error: ${memoryError.message}`
          )
        }
        if (internalError) {
          throw new TypeError(`WebGPU internal error: ${internalError.message}`)
        }

        return {
          device,
          resolutionUniform,
          dimensionsUniform,
          groupY,
          groupX,
          pipeline,
          context,
          format
        }
      })

      let textureY
      let textureX
      let textureExecId = 0
      on('texture', async (_, { webgpu, image }) => {
        const execId = ++textureExecId

        const { device, dimensionsUniform, pipeline, format, context } = webgpu
        const source = await createImageBitmap(image.canvas, {
          colorSpaceConversion: 'none'
        })
        if (execId !== textureExecId) {
          return
        }
        textureY?.destroy()
        textureY = device.createTexture({
          label: 'texture',
          format,
          size: [source.width, source.height],
          usage:
            GPUTextureUsage.TEXTURE_BINDING |
            GPUTextureUsage.COPY_DST |
            GPUTextureUsage.RENDER_ATTACHMENT
        })
        device.queue.copyExternalImageToTexture(
          { source, flipY: false },
          { texture: textureY },
          { width: source.width, height: source.height }
        )

        textureX?.destroy()
        textureX = device.createTexture({
          label: 'texture',
          format,
          size: [source.width, source.height],
          usage:
            GPUTextureUsage.TEXTURE_BINDING |
            GPUTextureUsage.COPY_DST |
            GPUTextureUsage.RENDER_ATTACHMENT
        })

        device.queue.writeBuffer(
          dimensionsUniform,
          0,
          new Float32Array([source.width, source.height])
        )
        context.canvas.width = source.width
        context.canvas.height = source.height

        return {
          groupY: device.createBindGroup({
            layout: pipeline.getBindGroupLayout(1),
            entries: [{ binding: 0, resource: textureY.createView() }]
          }),
          textureX,
          groupX: device.createBindGroup({
            layout: pipeline.getBindGroupLayout(1),
            entries: [{ binding: 0, resource: textureX.createView() }]
          }),
          fileName: image.canvas.dataset.name
        }
      })

      let lastBuffer
      const sqrt2pi = Math.sqrt(2 * Math.PI)
      on('weights', (slower, { webgpu, blur, cutoff, resolution }) => {
        const radius = Math.ceil(blur * cutoff)
        const blurSquared = blur * blur
        const weights = []
        for (let i = 0; i <= radius; i += resolution) {
          weights.push(
            (Math.exp((-i * i) / blurSquared / 2) * resolution) /
              (blur * sqrt2pi)
          )
        }
        const sum =
          weights.reduce((cum, curr) => cum + curr, 0) * 2 - weights[0]
        // console.log('sum of weights', sum)
        slower.textContent = weights.length

        const { device, pipeline } = webgpu
        if (lastBuffer?.size !== weights.length) {
          lastBuffer?.buffer.destroy()
          const size = 4 * weights.length
          const buffer = device.createBuffer({
            size,
            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
          })
          lastBuffer = {
            size,
            buffer,
            group: device.createBindGroup({
              layout: pipeline.getBindGroupLayout(2),
              entries: [{ binding: 0, resource: { buffer } }]
            })
          }
        }
        device.queue.writeBuffer(
          lastBuffer.buffer,
          0,
          new Float32Array(weights)
        )
        return lastBuffer.group
      })

      // https://sheeptester.github.io/words-go-here/misc/ece109-cumsheet.html
      // (week 6)
      // Phi(u) = (1 + erf(u / sqrt 2)) / 2 = int -infty..u N(0, 1) dz
      // area = 1 - 2 (1 - Phi(u)) = 2 Phi(u) - 1 = erf(u / sqrt 2)
      // then for N(0, sigma^2), it's Phi(u / sigma) = erf(u / (sigma sqrt 2))
      on('cutoff-calc', (span, { cutoff }) => {
        const area = erf(cutoff / Math.SQRT2)
        const missing = 1 - area
        const precision = Math.max(0, 1 - Math.log10(missing * 100))
        span.textContent = `With ${cutoff.toFixed(
          2
        )} × σ, you get an accuracy of ${(area * 100).toFixed(precision)}%.`
      })

      let outputExecId = 0
      on('output', async (_, { webgpu, texture, weights, resolution }) => {
        const execId = ++outputExecId

        const { device, resolutionUniform, context, pipeline, groupY, groupX } =
          webgpu
        const {
          groupY: textureGroupY,
          groupX: textureGroupX,
          textureX,
          fileName
        } = texture

        device.queue.writeBuffer(
          resolutionUniform,
          0,
          new Uint32Array([resolution])
        )

        const encoder = device.createCommandEncoder()
        const passY = encoder.beginRenderPass({
          colorAttachments: [
            {
              view: textureX.createView(),
              clearValue: [1, 0, 1, 1],
              loadOp: 'clear',
              storeOp: 'store'
            }
          ]
        })
        passY.setPipeline(pipeline)
        passY.setBindGroup(0, groupY)
        passY.setBindGroup(1, textureGroupY)
        passY.setBindGroup(2, weights)
        passY.draw(6)
        passY.end()
        const passX = encoder.beginRenderPass({
          colorAttachments: [
            {
              view: context.getCurrentTexture().createView(),
              clearValue: [1, 0, 1, 1],
              loadOp: 'clear',
              storeOp: 'store'
            }
          ]
        })
        passX.setPipeline(pipeline)
        passX.setBindGroup(0, groupX)
        passX.setBindGroup(1, textureGroupX)
        passX.setBindGroup(2, weights)
        passX.draw(6)
        passX.end()
        device.queue.submit([encoder.finish()])

        // toBlob/toDataURL returns a transparent image for WebGPU on Chrome
        // https://issues.chromium.org/issues/40168039
        return { fileName, canvas: context.canvas }
      })

      on('canvas2d', (ctx, { output: { fileName, canvas } }) => {
        ctx.canvas.width = canvas.width
        ctx.canvas.height = canvas.height
        // For some reason this works
        ctx.drawImage(canvas, 0, 0)

        return Out.from(fileName + '.png', ctx)
      })
    </script>
  </body>
</html>
